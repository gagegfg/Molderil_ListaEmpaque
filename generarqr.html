<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MOLDERIL - Generar Etiqueta QR (v6 - Carga Directa)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
          background-image: url('fondo.jpg');
          background-size: cover;
          background-position: center;
          background-repeat: no-repeat;
          background-attachment: fixed;
        }
        .backdrop-blur-lg {
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
        }
        #preview-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background-color: #e5e7eb;
        }
        #preview-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast-success { background-color: #16a34a; }
        .toast-error { background-color: #dc2626; }
        .toast-info { background-color: #2563eb; }
        .spinner {
            display: inline-block;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            width: 18px;
            height: 18px;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

<div id="static-loader" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 p-4 font-sans z-50 transition-opacity duration-500">
    <div class="relative bg-[#D2B48C]/20 backdrop-blur-lg border border-[#D2B48C]/30 p-8 rounded-xl shadow-2xl w-full max-w-md text-center">
        <img src="logo.jpg" alt="Logo Molderil" class="mx-auto mb-6 h-32 [filter:drop-shadow(2px_2px_4px_rgba(0,0,0,0.4))_drop_shadow(-2px_-2px_4px_rgba(255,255,255,0.6))]"/>
        <p id="loader-status" class="text-xl text-white mb-4 [text-shadow:_1px_1px_2px_rgba(0,0,0,0.5)]">Cargando aplicación...</p>
        <div class="w-full bg-white/20 rounded-full h-4 border border-white/30">
            <div id="loader-progress" class="bg-amber-400 h-full rounded-full transition-all duration-500" style="width: 10%"></div>
        </div>
    </div>
</div>


<div id="root"></div>
<div id="toast-container"></div>

<script type="text/babel">
    const { useState, useEffect, Fragment, useRef } = React;
    const { createRoot } = ReactDOM;
    const { jsPDF } = window.jspdf;

    // =================================================================
    // ### CONFIGURACIÓN: DATOS DEL REPOSITORIO ###
    // =================================================================
    const USUARIO_GITHUB = 'gagegfg';
    const REPO_NOMBRE = 'Molderil_ListaEmpaque';
    const RUTA_LOTE_LOGISTICO = 'lotelogistica.txt';
    const RUTA_HISTORICO_CSV = 'detallelotes.csv';
    const RUTA_NOTAS_CSV = 'notasskulote.csv';
    const RUTA_ARTICULOS_CSV = 'articulos.csv';
    const RUTA_CLS_TXT = 'cls.txt';
    
    // --- NUEVO: CONFIGURACIÓN DEL SISTEMA DE BLOQUEO ---
    const LOCK_FILE_PATH = 'lock.json';
    const LOCK_TIMEOUT = 45 * 1000; // 45 segundos
    const SESSION_ID = Date.now().toString(36) + Math.random().toString(36).substr(2);
    // =================================================================

    const Toast = ({ message, type, onHide }) => {
        useEffect(() => {
            const timer = setTimeout(onHide, 3000);
            return () => clearTimeout(timer);
        }, [onHide]);

        return (
            <div className={`toast show toast-${type}`}>
                {message}
            </div>
        );
    };
    
    const useToasts = () => {
        const [toasts, setToasts] = useState([]);
        const toastContainer = document.getElementById('toast-container');

        const showToast = (message, type = 'info') => {
            const id = Date.now();
            setToasts(prev => [...prev, { id, message, type }]);
        };

        useEffect(() => {
            const onHide = (id) => {
                setToasts(prev => prev.filter(toast => toast.id !== id));
            };
            
            const toastElements = toasts.map(toast => (
                <Toast key={toast.id} {...toast} onHide={() => onHide(toast.id)} />
            ));
            
            if (toastContainer) {
                ReactDOM.createPortal(toastElements, toastContainer);
            }
        }, [toasts, toastContainer]);

        return showToast;
    };

    const AppWrapper = () => {
        const [apiToken, setApiToken] = useState(null);
        const [isReady, setIsReady] = useState(false);

        useEffect(() => {
            const fetchToken = async () => {
                try {
                    const url = `https://raw.githubusercontent.com/${USUARIO_GITHUB}/${REPO_NOMBRE}/main/${RUTA_CLS_TXT}`;
                    const response = await fetch(url, { cache: "no-store" });
                    if (!response.ok) throw new Error(`No se pudo cargar ${RUTA_CLS_TXT}`);
                    let rawToken = await response.text();
                    rawToken = rawToken.replace(/aaaa/g, '').replace(/bbbb/g, '').replace(/cccc/g, '');
                    setApiToken(rawToken.trim());
                } catch (error) {
                    console.error("Error al obtener el token:", error);
                } finally {
                    setIsReady(true);
                }
            };
            fetchToken();
        }, []);
        
        if (!isReady) return null;

        return <App apiToken={apiToken} />;
    };

    const App = ({ apiToken }) => {
        const showToast = useToasts();
        const [appIsLoading, setAppIsLoading] = useState(true);
        const [articulos, setArticulos] = useState([]);
        const [searchTerm, setSearchTerm] = useState('');
        const [selectedArticulo, setSelectedArticulo] = useState(null);
        const [lotesProduccion, setLotesProduccion] = useState(['']);
        const [numeroDePallet, setNumeroDePallet] = useState('');
        const [isPalletNumEditable, setIsPalletNumEditable] = useState(false);
        const [cantidadCopias, setCantidadCopias] = useState(2);
        
        const getTodayDateString = () => {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        const [fechaProd, setFechaProd] = useState(getTodayDateString());

        const [cantidad, setCantidad] = useState('');
        const [uom, setUom] = useState('Unidad');
        const [previewPdfUrl, setPreviewPdfUrl] = useState(null);
        const [isSaving, setIsSaving] = useState(false);
        const [observacion, setObservacion] = useState('');
        const articuloInputRef = useRef(null);
        const loteInputRefs = useRef([]);
        const [refreshState, setRefreshState] = useState('idle'); // idle, loading, error, success
        
        const handleRefreshPalletNumber = async (isSilent = false) => {
            if (!isSilent) setRefreshState('loading');
            
            const url = `https://raw.githubusercontent.com/${USUARIO_GITHUB}/${REPO_NOMBRE}/main/${RUTA_LOTE_LOGISTICO}?t=${new Date().getTime()}`;
            try {
                const response = await fetch(url, { cache: "no-store" });
                if (!response.ok) throw new Error('No se pudo verificar el Nº de pallet.');
                const text = await response.text();
                const numeroBase = parseInt(text.trim(), 10);
                if (isNaN(numeroBase)) throw new Error('El archivo de pallet está corrupto.');
                
                const proximoNumero = numeroBase + 1;
                const numeroActual = parseInt(numeroDePallet, 10);

                if (numeroActual !== proximoNumero) {
                    setNumeroDePallet(proximoNumero);
                    if (!isSilent) {
                        showToast(`Nº de pallet actualizado al siguiente disponible: ${proximoNumero}.`, 'info');
                    }
                    if (previewPdfUrl) {
                        setPreviewPdfUrl(null);
                        showToast('El Nº de pallet cambió. Por favor, genere una nueva vista previa.', 'info');
                    }
                } else {
                    if (!isSilent) {
                         showToast('El número de pallet ya está actualizado.', 'success');
                    }
                }
                if (!isSilent) {
                    setRefreshState('success');
                    setTimeout(() => setRefreshState('idle'), 2000);
                }
                return proximoNumero;
            } catch (error) {
                console.error("Error al refrescar número de pallet:", error);
                if (!isSilent) {
                    showToast(error.message, 'error');
                    setRefreshState('error');
                    setTimeout(() => setRefreshState('idle'), 3000); // Reset error state after 3s
                }
                return null;
            }
        };

        const RUTA_PSW_SKU = 'pswsku.txt'; // Define the path to the password file

        const validatePassword = async (password) => {
            try {
                const url = `https://raw.githubusercontent.com/${USUARIO_GITHUB}/${REPO_NOMBRE}/main/${RUTA_PSW_SKU}?t=${new Date().getTime()}`;
                const response = await fetch(url, { cache: "no-store" });
                if (!response.ok) throw new Error('No se pudo cargar el archivo de contraseña.');
                const storedPassword = (await response.text()).trim();
                return password === storedPassword;
            } catch (error) {
                console.error("Error al validar contraseña:", error);
                showToast(`Error al validar contraseña: ${error.message}`, 'error');
                return false;
            }
        };

        const handleManualPalletUpdate = async () => {
            const newPalletInput = prompt("Ingrese el nuevo número de pallet:");
            if (newPalletInput === null) return; // User cancelled

            const newPalletNum = parseInt(newPalletInput, 10);

            if (isNaN(newPalletNum) || newPalletNum <= 0) {
                showToast("El número de pallet debe ser un entero positivo.", 'error');
                return;
            }

            // Get the current pallet number from the file to compare
            let currentFilePalletNum = 0;
            try {
                const url = `https://raw.githubusercontent.com/${USUARIO_GITHUB}/${REPO_NOMBRE}/main/${RUTA_LOTE_LOGISTICO}?t=${new Date().getTime()}`;
                const response = await fetch(url, { cache: "no-store" });
                if (!response.ok) throw new Error('No se pudo verificar el Nº de pallet actual.');
                const text = await response.text();
                currentFilePalletNum = parseInt(text.trim(), 10);
                if (isNaN(currentFilePalletNum)) throw new Error('El archivo de pallet está corrupto.');
            } catch (error) {
                console.error("Error al obtener el número de pallet del archivo:", error);
                showToast(`Error al obtener el número de pallet del archivo: ${error.message}`, 'error');
                return;
            }

            const currentDisplayedPalletNum = parseInt(numeroDePallet, 10);

            if (newPalletNum <= currentFilePalletNum || newPalletNum <= currentDisplayedPalletNum) {
                showToast(`El nuevo número de pallet (${newPalletNum}) debe ser mayor que el actual en archivo (${currentFilePalletNum}) y en pantalla (${currentDisplayedPalletNum}).`, 'error');
                return;
            }

            const passwordInput = prompt("Ingrese la clave para actualizar el número de pallet:");
            if (passwordInput === null) return; // User cancelled

            const isPasswordValid = await validatePassword(passwordInput);
            if (!isPasswordValid) {
                showToast("Clave incorrecta. No se puede actualizar el número de pallet.", 'error');
                return;
            }

            // Acquire lock before updating the file
            const lock = await acquireLock('manualPalletUpdate');
            if (!lock.success) {
                showToast(`No se pudo actualizar. ${lock.error}. Intente de nuevo.`, 'error');
                return;
            }

            try {
                const updateSuccess = await updateLoteFile(newPalletNum);
                if (updateSuccess) {
                    setNumeroDePallet(newPalletNum + 1); // Set to next available number
                    showToast(`Número de pallet actualizado manualmente a ${newPalletNum}.`, 'success');
                    if (previewPdfUrl) {
                        setPreviewPdfUrl(null);
                        showToast('El Nº de pallet cambió. Por favor, genere una nueva vista previa.', 'info');
                    }
                } else {
                    showToast("Fallo al actualizar el número de pallet manualmente.", 'error');
                }
            } catch (error) {
                console.error("Error en handleManualPalletUpdate:", error);
                showToast(`Error al actualizar el número de pallet: ${error.message}`, 'error');
            } finally {
                await releaseLock();
            }
        };

        useEffect(() => {
            const interval = setInterval(() => {
                const now = new Date();
                const hour = now.getHours();
                if (hour >= 5 && hour < 22) {
                    console.log("Verificación periódica de número de pallet...");
                    handleRefreshPalletNumber(true); // silent = true
                }
            }, Math.floor(Math.random() * (5 * 60 * 1000 - 1 * 60 * 1000 + 1)) + 1 * 60 * 1000); // Entre 1 y 5 minutos

            return () => clearInterval(interval);
        }, [numeroDePallet, previewPdfUrl]); // Dependencias para tener valores actualizados


        const acquireLock = async (operationName) => {
            const url = `https://api.github.com/repos/${USUARIO_GITHUB}/${REPO_NOMBRE}/contents/${LOCK_FILE_PATH}`;
            let currentSha = null;
            try {
                const response = await fetch(`${url}?t=${new Date().getTime()}`, {
                    headers: { 'Authorization': `token ${apiToken}` }, cache: 'no-store'
                });

                if (response.ok) {
                    const fileData = await response.json();
                    currentSha = fileData.sha;
                    const content = atob(fileData.content);

                    if (content && content.trim()) {
                        const lock = JSON.parse(content);
                        const isLockedByOther = lock.sessionId && lock.sessionId !== SESSION_ID;
                        const isExpired = Date.now() - lock.timestamp > LOCK_TIMEOUT;

                        if (isLockedByOther && !isExpired) {
                            return { success: false, error: `Sistema bloqueado por otra sesión. Operación en curso: ${lock.operation || 'N/A'}` };
                        }
                    }
                } else if (response.status !== 404) {
                    throw new Error(`Error al leer el archivo de bloqueo: ${response.statusText}`);
                }

                const lockContent = { sessionId: SESSION_ID, timestamp: Date.now(), operation: operationName };
                const updateResponse = await fetch(url, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${apiToken}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: `Locking for operation: ${operationName}`,
                        content: btoa(JSON.stringify(lockContent)),
                        sha: currentSha,
                    }),
                });

                if (!updateResponse.ok) throw new Error(`No se pudo adquirir el bloqueo: ${updateResponse.statusText}`);
                
                return { success: true };

            } catch (error) {
                if (error instanceof SyntaxError) {
                    console.warn("lock.json contenía JSON inválido, se procederá a sobreescribir.");
                    return { success: true };
                }
                console.error("Error en acquireLock:", error);
                return { success: false, error: error.message };
            }
        };

        const releaseLock = async () => {
            const url = `https://api.github.com/repos/${USUARIO_GITHUB}/${REPO_NOMBRE}/contents/${LOCK_FILE_PATH}`;
            try {
                const response = await fetch(`${url}?t=${new Date().getTime()}`, {
                    headers: { 'Authorization': `token ${apiToken}` }, cache: 'no-store'
                });
        
                if (response.ok) {
                    const fileData = await response.json();
                    const content = atob(fileData.content);
                    if (content) {
                        const lock = JSON.parse(content);
                        if (lock.sessionId && lock.sessionId !== SESSION_ID) {
                            console.warn("Intento de liberar un bloqueo que no pertenece a esta sesión. Se omite.");
                            return;
                        }
                    }

                    const updateResponse = await fetch(url, {
                        method: 'PUT',
                        headers: { 'Authorization': `token ${apiToken}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: 'Releasing lock',
                            content: btoa(''),
                            sha: fileData.sha,
                        }),
                    });
                    if (!updateResponse.ok) console.error("Error al liberar el bloqueo, puede expirar automáticamente.");
                }
            } catch (error) {
                console.error("Error en releaseLock:", error);
            }
        };

        // --- MODIFICACIÓN: SINCRONIZAR HORA CON INTERNET ---
        useEffect(() => {
            const fetchInternetTime = async () => {
                try {
                    const response = await fetch('https://worldtimeapi.org/api/timezone/America/Argentina/Buenos_Aires', { cache: "no-store" });
                    if (!response.ok) throw new Error('No se pudo conectar al servidor de tiempo.');
                    
                    const data = await response.json();
                    const internetDate = data.datetime.substring(0, 10); // Extrae 'YYYY-MM-DD'
                    setFechaProd(internetDate);
                    showToast('Fecha sincronizada con hora de internet.', 'info');
                } catch (error) {
                    console.error("Error al obtener la hora de internet:", error);
                    showToast('Fallo al sincronizar fecha. Usando hora local.', 'error');
                    // El estado ya tiene la fecha local como respaldo, no es necesario hacer nada más.
                }
            };
            fetchInternetTime();
        }, []); // El array vacío asegura que esto se ejecute solo una vez cuando carga la app.
        // --- FIN DE LA MODIFICACIÓN ---


        useEffect(() => {
            const staticLoader = document.getElementById('static-loader');
            const loaderStatus = document.getElementById('loader-status');
            const loaderProgress = document.getElementById('loader-progress');

            const fetchInitialData = async () => {
                const url = `https://raw.githubusercontent.com/${USUARIO_GITHUB}/${REPO_NOMBRE}/main/${RUTA_LOTE_LOGISTICO}`;
                try {
                    const response = await fetch(url, { cache: "no-store" });
                    if (!response.ok) throw new Error('No se pudo obtener el número de pallet desde GitHub.');
                    const text = await response.text();
                    const numeroBase = parseInt(text.trim(), 10);
                    if (isNaN(numeroBase)) throw new Error('El contenido del archivo no es un número.');
                    setNumeroDePallet(numeroBase + 1);
                } catch (error) {
                    console.error("Error al cargar número de pallet:", error);
                    showToast(`Error: ${error.message}\nIngrese el número de pallet manualmente.`, 'error');
                    setNumeroDePallet('');
                    setIsPalletNumEditable(true);
                }
            };

            const fetchArticulos = async () => {
                try {
                    // MODIFICADO: Se añade un parámetro de tiempo para evitar la caché
                    const url = `https://raw.githubusercontent.com/${USUARIO_GITHUB}/${REPO_NOMBRE}/main/${RUTA_ARTICULOS_CSV}?t=${new Date().getTime()}`;
                    const response = await fetch(url, { cache: "no-store" });
                    if (!response.ok) throw new Error(`No se pudo cargar ${RUTA_ARTICULOS_CSV}`);
                    const text = await response.text();
                    const rows = text.split('\n').slice(1);
                    const parsedArticulos = rows.map(row => {
                        const [tipo_articulo, codigo_articulo, descripcionLarga, descripcionCorta] = row.split(';');
                        return { 
                            tipo: tipo_articulo?.trim().toUpperCase(), 
                            sku: codigo_articulo?.trim(), 
                            descripcionLarga: descripcionLarga?.trim(),
                            descripcionCorta: descripcionCorta?.trim() 
                        };
                    }).filter(art => art.sku && art.descripcionLarga);
                    setArticulos(parsedArticulos);
                } catch (error) {
                    console.error(`Error loading ${RUTA_ARTICULOS_CSV}:`, error);
                    showToast("Error al cargar la lista de artículos.", 'error');
                }
            };

            const loadingTasks = [
                { status: "Inicializando...", duration: 300, progress: 20 },
                { status: "Cargando número de pallet...", duration: 800, progress: 40, action: fetchInitialData },
                { status: "Cargando lista de artículos...", duration: 800, progress: 70, action: fetchArticulos },
                { status: "¡Listo!", duration: 500, progress: 100 }
            ];

            let currentTask = 0;
            const runLoadingTask = () => {
                if (currentTask < loadingTasks.length) {
                    const task = loadingTasks[currentTask];
                    if (loaderStatus) loaderStatus.textContent = task.status;
                    if (loaderProgress) loaderProgress.style.width = `${task.progress}%`;
                    if (task.action) task.action();
                    setTimeout(() => {
                        currentTask++;
                        runLoadingTask();
                    }, task.duration);
                } else {
                    if (staticLoader) {
                        staticLoader.classList.add('opacity-0');
                        setTimeout(() => {
                            staticLoader.style.display = 'none';
                            setAppIsLoading(false);
                        }, 500);
                    }
                }
            };
            runLoadingTask();
        }, []);

        useEffect(() => {
            if (!appIsLoading && articuloInputRef.current) {
                articuloInputRef.current.focus();
            }
        }, [appIsLoading]);
        
        useEffect(() => {
            if (selectedArticulo) {
                const specialTypes = ['TULIPAS', 'PIROTINES', 'MADALENAS', 'FUNDAS'];
                if (specialTypes.includes(selectedArticulo.tipo)) { setUom('Millar'); } 
                else { setUom('Unidad'); }
            }
        }, [selectedArticulo]);
        
        useEffect(() => {
            const lastLoteIndex = lotesProduccion.length - 1;
            if (loteInputRefs.current[lastLoteIndex]) {
                loteInputRefs.current[lastLoteIndex].focus();
            }
        }, [lotesProduccion.length]);

        const updateLoteFile = async (nuevoContenido) => {
            const url = `https://api.github.com/repos/${USUARIO_GITHUB}/${REPO_NOMBRE}/contents/${RUTA_LOTE_LOGISTICO}`;
            try {
                const fileResponse = await fetch(url, { headers: { 'Authorization': `token ${apiToken}` } });
                if (!fileResponse.ok) throw new Error(`Error ${fileResponse.status}: No se pudo obtener info del archivo de lotes.`);
                const fileData = await fileResponse.json();
                const putResponse = await fetch(url, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${apiToken}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: `Actualizando pallet a ${nuevoContenido}`,
                        content: btoa(String(nuevoContenido)),
                        sha: fileData.sha,
                    }),
                });
                if (!putResponse.ok) throw new Error(`Error ${putResponse.status} al guardar el número de pallet.`);
                console.log(`Número de Pallet ${nuevoContenido} guardado correctamente en GitHub.`);
                return true;
            } catch (error) {
                console.error("Error en updateLoteFile:", error);
                showToast(`ERROR: No se pudo guardar el número de pallet.\n${error.message}`, 'error');
                return false;
            }
        };

        const appendToHistoryFile = async (lineaCsv) => {
            const url = `https://api.github.com/repos/${USUARIO_GITHUB}/${REPO_NOMBRE}/contents/${RUTA_HISTORICO_CSV}`;
            try {
                let fileData;
                let contenidoActual = "";
                let sha = null;
                const fileResponse = await fetch(url, { headers: { 'Authorization': `token ${apiToken}` } });
                if (fileResponse.ok) {
                    fileData = await fileResponse.json();
                    contenidoActual = atob(fileData.content);
                    sha = fileData.sha;
                } else if (fileResponse.status !== 404) {
                    throw new Error(`Error ${fileResponse.status}: No se pudo obtener info del archivo histórico.`);
                }
                const nuevoContenido = contenidoActual ? `${contenidoActual.trim()}\n${lineaCsv}` : lineaCsv;
                const putResponse = await fetch(url, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${apiToken}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: `Añadiendo pallet ${numeroDePallet} al histórico`,
                        content: btoa(nuevoContenido),
                        ...(sha && { sha }),
                    }),
                });
                if (!putResponse.ok) throw new Error(`Error ${putResponse.status} al guardar en el histórico.`);
                console.log("Registro añadido al histórico correctamente.");
                return true;
            } catch (error) {
                console.error("Error en appendToHistoryFile:", error);
                showToast(`ERROR: No se pudo guardar el registro en el histórico.\n${error.message}`, 'error');
                return false;
            }
        };

        const appendToNotesFile = async (lineaCsv) => {
            const url = `https://api.github.com/repos/${USUARIO_GITHUB}/${REPO_NOMBRE}/contents/${RUTA_NOTAS_CSV}`;
            try {
                let fileData;
                let contenidoActual = "";
                let sha = null;
                const fileResponse = await fetch(url, { headers: { 'Authorization': `token ${apiToken}` } });
                if (fileResponse.ok) {
                    fileData = await fileResponse.json();
                    contenidoActual = atob(fileData.content);
                    sha = fileData.sha;
                } else if (fileResponse.status !== 404) {
                    throw new Error(`Error ${fileResponse.status}: No se pudo obtener info del archivo de notas.`);
                }
                const nuevoContenido = contenidoActual ? `${contenidoActual.trim()}\n${lineaCsv}` : lineaCsv;
                const putResponse = await fetch(url, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${apiToken}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: `Añadiendo nota para pallet ${numeroDePallet}`,
                        content: btoa(nuevoContenido),
                        ...(sha && { sha }),
                    }),
                });
                if (!putResponse.ok) throw new Error(`Error ${putResponse.status} al guardar en el archivo de notas.`);
                console.log("Nota añadida al histórico correctamente.");
                return true;
            } catch (error) {
                console.error("Error en appendToNotesFile:", error);
                showToast(`ERROR: No se pudo guardar la nota.\n${error.message}`, 'error');
                return false;
            }
        };
        
        const handleLoteProdChange = (index, value) => {
            const regex = /^\d*$/;
            if (regex.test(value)) {
                const nuevosLotes = [...lotesProduccion];
                nuevosLotes[index] = value;
                setLotesProduccion(nuevosLotes);
            }
        };

        const addLoteProdField = () => {
            if (lotesProduccion.length < 4) {
                setLotesProduccion([...lotesProduccion, '']);
            }
        };
        
        const handleCantidadChange = (e) => {
            let value = e.target.value;
            value = value.replace(/[^0-9,]/g, '');
            const parts = value.split(',');
            if (parts.length > 2) {
                value = parts[0] + ',' + parts.slice(1).join('');
            }
            setCantidad(value);
        };
        
        const formatNumberES = (numStr) => {
            if (!numStr) return '';
            const [integerPart, decimalPart] = numStr.split(',');
            const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ".");
            return decimalPart !== undefined ? `${formattedInteger},${decimalPart}` : formattedInteger;
        };

        const filteredArticulos = searchTerm ? articulos.filter(art => art.sku.toLowerCase().includes(searchTerm.toLowerCase()) || art.descripcionLarga.toLowerCase().includes(searchTerm.toLowerCase())) : [];

        const drawLabelOnDoc = async (doc, data) => {
            const pageW = 210;
            const margin = 8;
            const contentW = pageW - (margin * 2);
            let currentY = margin;

            doc.setFontSize(24);
            doc.setFont("helvetica", "bold");
            doc.text("MOLDERIL S.A.", pageW / 2, currentY + 8, { align: "center" });
            currentY += 15;
            doc.line(margin, currentY, pageW - margin, currentY);
            currentY += 10;
            
            // --- MODIFICADO: Lógica para ajustar tamaño de fuente de la descripción ---
            doc.setFont("helvetica", "bold");
            const baseFontSize = 84;
            doc.setFontSize(baseFontSize); // Set to base size to calculate initial line count
            
            let descLines = doc.splitTextToSize(data.descripcion, contentW);
            let finalFontSize = baseFontSize;

            // Si la descripción ocupa más de 3 líneas con el tamaño base, se reduce la fuente.
            if (descLines.length > 3) {
                finalFontSize = 60; // Usar un tamaño de fuente más pequeño y fijo
            }
            
            doc.setFontSize(finalFontSize); // Establecer el tamaño de fuente final para el renderizado
            const lineHeight = finalFontSize / 3; // Calcular la altura de la línea en función del tamaño de fuente final

            doc.text(descLines, pageW / 2, currentY + lineHeight, { align: "center", lineHeightFactor: 1 });
            currentY += (descLines.length * lineHeight) + 10;
            // --- FIN DE LA MODIFICACIÓN ---

            doc.line(margin, currentY, pageW - margin, currentY);
            currentY += 2;
            doc.setFontSize(20);
            doc.setFont("helvetica", "bold");
            doc.text(`SKU: ${data.sku}`, margin, currentY + 12);
            const lotesProdString = data.lotes.join(' / ');
            const lotesDisplayString = data.observacion ? `${lotesProdString} (*)` : lotesProdString;
            if (lotesProdString) {
                doc.setFontSize(18);
                doc.setFont("helvetica", "normal");
                doc.text(`Lotes: ${lotesDisplayString}`, pageW - margin, currentY + 12, { align: "right" });
            }
            currentY += 18;
            doc.line(margin, currentY, pageW - margin, currentY);
            currentY += 8;
            const formattedCantidad = formatNumberES(data.cantidad);
            const uomText = data.uom === 'Unidad' ? 'Unidades' : 'Millares';
            const cantidadString = `${formattedCantidad} ${uomText}`;
            doc.setFont("helvetica", "bold");
            doc.setFontSize(44);
            const cantidadWidth = doc.getStringUnitWidth(cantidadString) * doc.getFontSize() / doc.internal.scaleFactor;
            const cantidadX = (pageW - cantidadWidth) / 2;
            doc.text(cantidadString, cantidadX, currentY + 12);
            currentY += 20;
            const qrSize = 90;
            const qrX = (pageW - qrSize) / 2;
            const qrY = currentY;
            const qrImageData = await QRCode.toDataURL(data.qrString, { width: 400, margin: 2, errorCorrectionLevel: 'M' });
            doc.addImage(qrImageData, 'PNG', qrX, qrY, qrSize, qrSize);
            currentY += qrSize + 5;
            doc.line(margin, currentY, pageW - margin, currentY);
            currentY += 5;
            doc.setFontSize(22);
            doc.setFont("helvetica", "bold");
            doc.text("Nº de Pallet", margin, currentY + 10);
            doc.text("Fabricación", pageW - margin, currentY + 10, { align: "right" });
            doc.setFontSize(36);
            doc.text(String(data.palletId), margin, currentY + 22);
            doc.setFontSize(22);
            doc.text(new Date(data.fechaProd + 'T00:00:00').toLocaleDateString('es-ES'), pageW - margin, currentY + 22, { align: "right" });
        };

        const getLabelData = () => {
            const formatQrDate = (dateString) => {
                if (!dateString) return '';
                const date = new Date(dateString + 'T00:00:00');
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}/${month}/${year}`;
            };
            const cantidadParaQR = cantidad.replace(',', '.');
            const lotesProduccionFiltrados = lotesProduccion.filter(lote => lote.trim() !== '');
            const lotesParaQR = lotesProduccionFiltrados.join('#');
            const qrString = [
                selectedArticulo.sku || '',
                selectedArticulo.descripcionLarga || '',
                String(numeroDePallet) || '',
                lotesParaQR,
                formatQrDate(fechaProd),
                cantidadParaQR || '',
                uom || '',
            ].join(';');
            return {
                sku: selectedArticulo.sku,
                descripcion: selectedArticulo.descripcionCorta || selectedArticulo.descripcionLarga,
                lotes: lotesProduccionFiltrados,
                cantidad: cantidad,
                uom,
                fechaProd,
                palletId: numeroDePallet,
                qrString: qrString,
                observacion: observacion.trim()
            };
        }

        const handleGeneratePreview = async (isRegeneration = false) => {
            if (!isRegeneration) {
                const updatedPalletNum = await handleRefreshPalletNumber(true);
                if (updatedPalletNum && parseInt(numeroDePallet, 10) !== updatedPalletNum) {
                    // El número de pallet fue actualizado, el usuario debe estar al tanto.
                    // La invalidación de la preview ya la hace handleRefreshPalletNumber.
                    return;
                }
            }

            const lotesValidos = lotesProduccion.some(lote => lote.trim() !== '');
            if (!selectedArticulo || !cantidad || !lotesValidos) {
                showToast("Complete Artículo, Cantidad y al menos un Lote.", 'error');
                return;
            }
            const data = getLabelData();
            const doc = new jsPDF('p', 'mm', 'a4');
            await drawLabelOnDoc(doc, data);
            const pdfDataUrl = doc.output('datauristring');
            setPreviewPdfUrl(pdfDataUrl);
        };
        
        const handleGenerateAndPrintPDF = async () => {
            if (isSaving) return;
            setIsSaving(true);

            const numCopias = parseInt(cantidadCopias, 10);
            let palletNum = parseInt(numeroDePallet, 10);

            if (isNaN(numCopias) || numCopias < 1 || isNaN(palletNum) || !previewPdfUrl) {
                showToast("Genere una vista previa y verifique los datos.", 'error');
                setIsSaving(false);
                return;
            }
            if (!apiToken) {
                showToast("ERROR: Clave de API no disponible. No se puede guardar.", 'error');
                setIsSaving(false);
                return;
            }

            const lock = await acquireLock('generateLabel');
            if (!lock.success) {
                showToast(`No se pudo guardar. ${lock.error}. Intente de nuevo.`, 'error');
                setIsSaving(false);
                return;
            }

            try {
                const url = `https://raw.githubusercontent.com/${USUARIO_GITHUB}/${REPO_NOMBRE}/main/${RUTA_LOTE_LOGISTICO}?t=${new Date().getTime()}`;
                const response = await fetch(url, { cache: "no-store" });
                if (!response.ok) throw new Error('No se pudo verificar el último número de pallet.');
                
                const text = await response.text();
                const ultimoPalletGuardado = parseInt(text.trim(), 10);

                if (isNaN(ultimoPalletGuardado)) throw new Error('El contenido del archivo de pallet no es un número.');

                if (palletNum <= ultimoPalletGuardado) {
                    const nuevoNumeroSugerido = ultimoPalletGuardado + 1;
                    showToast(`¡Conflicto! El Pallet ${palletNum} ya fue usado. Se actualizó al Nº ${nuevoNumeroSugerido}. Por favor, revise la nueva vista previa y guarde de nuevo.`, 'error');
                    setNumeroDePallet(nuevoNumeroSugerido);
                    
                    // Forzar regeneración de la vista previa con el número correcto
                    setTimeout(() => handleGeneratePreview(true), 100);
                    return; 
                }

                const data = getLabelData();
                const lineaCsv = `${data.qrString};FALSE;`;
                const historySaved = await appendToHistoryFile(lineaCsv);
                if (!historySaved) throw new Error("Fallo al guardar en el histórico.");

                if (data.observacion) {
                    const sanitizedObservacion = data.observacion.replace(/;/g, ',').replace(/\n/g, ' ');
                    const lineaNotas = `${data.sku};${data.palletId};${sanitizedObservacion}`;
                    const notesSaved = await appendToNotesFile(lineaNotas);
                    if (!notesSaved) throw new Error("Fallo al guardar la nota.");
                }

                const palletNumSaved = await updateLoteFile(palletNum);
                if (!palletNumSaved) throw new Error("Fallo al actualizar el número de pallet. ¡CONTACTE A SOPORTE!");
                
                showToast(`Pallet Nº ${palletNum} guardado correctamente.`, 'success');
                const doc = new jsPDF('p', 'mm', 'a4');
                for (let i = 0; i < numCopias; i++) {
                    if (i > 0) doc.addPage();
                    await drawLabelOnDoc(doc, data);
                }
                
                // ### INICIO DE LA MODIFICACIÓN DE IMPRESIÓN ###
                const isMobile = /Android|iPhone/i.test(navigator.userAgent);

                // Siempre guardar el archivo, como se hacía antes.
                doc.save(`etiqueta_pallet_${palletNum}.pdf`);

                if (!isMobile) {
                    // En escritorio, intentar abrir el diálogo de impresión.
                    try {
                        const pdfBlob = doc.output('blob');
                        const blobUrl = URL.createObjectURL(pdfBlob);
                        
                        const iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.src = blobUrl;
                        
                        document.body.appendChild(iframe);
                        
                        iframe.onload = () => {
                            setTimeout(() => {
                                try {
                                    iframe.contentWindow.focus();
                                    iframe.contentWindow.print();
                                } catch (e) {
                                    console.error("No se pudo abrir el diálogo de impresión.", e);
                                    showToast("No se pudo abrir el diálogo de impresión automáticamente.", "error");
                                } finally {
                                    // Limpiar después de un tiempo prudencial
                                    setTimeout(() => {
                                        document.body.removeChild(iframe);
                                        URL.revokeObjectURL(blobUrl);
                                    }, 60000);
                                }
                            }, 1); // Un pequeño delay puede ser necesario
                        };
                    } catch (e) {
                        console.error("Error al crear el iframe de impresión:", e);
                        showToast("Error al preparar la impresión automática.", "error");
                    }
                }
                // ### FIN DE LA MODIFICACIÓN DE IMPRESIÓN ###

                setNumeroDePallet(palletNum + 1);
                setSelectedArticulo(null);
                setSearchTerm('');
                setLotesProduccion(['']);
                setCantidad('');
                setObservacion('');
                setPreviewPdfUrl(null);

            } catch (error) {
                showToast(`ERROR CRÍTICO: ${error.message}`, 'error');
            } finally {
                await releaseLock();
                setIsSaving(false);
            }
        };
        
        if (appIsLoading) {
            return null;
        }

        return (
            <Fragment>
                <div className="min-h-screen p-4 flex flex-col" style={{background: 'rgba(243, 244, 246, 0.8)'}}>
                    <div className="bg-white/30 backdrop-blur-lg border border-white/50 p-6 rounded-xl shadow-lg flex-grow">
                        <div className="flex justify-between items-center mb-6">
                            <h1 className="text-3xl font-extrabold text-gray-900">Generar Etiqueta de Pallet</h1>
                            <a href="index.html" className="bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow-md border-b-4 border-green-800 hover:bg-green-700 active:translate-y-px active:border-b-2 transition-all duration-150 flex items-center">🏠 Volver</a>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div className="space-y-4">
                                <div className="relative">
                                    <label className="block text-base font-bold text-black">Artículo (Buscar por SKU o Descripción)</label>
                                    <input type="text" ref={articuloInputRef} value={searchTerm} onChange={e => { setSearchTerm(e.target.value); setSelectedArticulo(null); setPreviewPdfUrl(null); }} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" />
                                    {searchTerm && filteredArticulos.length > 0 && (
                                        <ul className="absolute z-10 w-full bg-white border rounded-md mt-1 max-h-40 overflow-y-auto shadow-lg">
                                            {filteredArticulos.map(art => (
                                                <li key={art.sku} className="p-2 hover:bg-indigo-100 cursor-pointer" onClick={() => { setSelectedArticulo(art); setSearchTerm(`${art.sku} - ${art.descripcionLarga}`); }}>
                                                    {art.sku} - {art.descripcionLarga}
                                                </li>
                                            ))}
                                        </ul>
                                    )}
                                </div>
                                <div>
                                    <label className="block text-base font-bold text-black">Lotes de Producción</label>
                                    {lotesProduccion.map((lote, index) => (
                                        <input 
                                            key={index}
                                            ref={el => loteInputRefs.current[index] = el}
                                            type="text" 
                                            value={lote} 
                                            onChange={e => handleLoteProdChange(index, e.target.value)} 
                                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" 
                                        />
                                    ))}
                                    {lotesProduccion.length < 4 && (
                                        <button onClick={addLoteProdField} className="mt-2 text-sm font-semibold text-blue-600 hover:text-blue-800 flex items-center">
                                            <span className="text-lg mr-1">+</span> Añadir otro lote
                                        </button>
                                    )}
                                </div>
                                <div>
                                    <label className="block text-base font-bold text-black">Número de Pallet (Automático)</label>
                                    <div className="mt-1 flex rounded-md shadow-sm">
                                        <input type="number" value={numeroDePallet} readOnly={!isPalletNumEditable} onChange={e => setNumeroDePallet(e.target.value)} className={`block w-full rounded-none rounded-l-md border-gray-300 p-2 border ${!isPalletNumEditable ? 'bg-gray-100' : ''}`} />
                                        <button 
                                            type="button"
                                            onClick={() => handleRefreshPalletNumber(false)}
                                            disabled={refreshState === 'loading'}
                                            className="relative -ml-px inline-flex items-center space-x-2 rounded-r-md border border-gray-300 bg-gray-50 px-3 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-100 disabled:opacity-50"
                                            title="Verificar último número de pallet"
                                        >
                                            <i className={`fas fa-sync-alt h-5 w-5 ${ 
                                                refreshState === 'loading' ? 'animate-spin text-red-500' :
                                                refreshState === 'success' ? 'text-green-500' :
                                                refreshState === 'error' ? 'text-red-500' :
                                                'text-blue-500'
                                            }`}></i>
                                            <span>Refrescar</span>
                                        </button>
                                        <button 
                                            type="button"
                                            onClick={handleManualPalletUpdate}
                                            className="relative -ml-px inline-flex items-center space-x-2 rounded-r-md border border-gray-300 bg-gray-50 px-3 py-2 text-sm font-semibold text-gray-700 hover:bg-gray-100 disabled:opacity-50"
                                            title="Ingresar número de pallet manualmente"
                                        >
                                            <i className="fas fa-edit h-5 w-5 text-purple-500"></i>
                                            <span>Manual</span>
                                        </button>
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-base font-bold text-black">Cantidad de Copias</label>
                                    <input type="number" min="1" value={cantidadCopias} onChange={e => setCantidadCopias(e.target.value)} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" />
                                </div>
                                <div>
                                    <label className="block text-base font-bold text-black">Fecha de Producción</label>
                                    <input type="date" value={fechaProd} onChange={e => setFechaProd(e.target.value)} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" />
                                </div>
                                <div>
                                    <label className="block text-base font-bold text-black">Cantidad (por etiqueta)</label>
                                    <input type="text" value={cantidad} onChange={handleCantidadChange} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" placeholder="Ej: 1234,56"/>
                                </div>
                                <div>
                                    <label className="block text-base font-bold text-black">Unidad de Medida</label>
                                    <select value={uom} onChange={e => setUom(e.target.value)} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border">
                                        <option>Unidad</option>
                                        <option>Millar</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="block text-base font-bold text-black">Observaciones (Opcional)</label>
                                    <textarea
                                        value={observacion}
                                        onChange={e => setObservacion(e.target.value)}
                                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border"
                                        rows="2"
                                        placeholder="Información adicional para el registro interno..."
                                    ></textarea>
                                </div>
                                <button onClick={handleGeneratePreview} className="w-full bg-blue-600 text-white font-semibold py-3 px-4 rounded-md shadow-md hover:bg-blue-700 text-xl flex items-center justify-center">
                                    Generar Vista Previa
                                </button>
                            </div>
                            <div>
                                <h3 className="text-lg font-medium text-gray-900 mb-2">Vista Previa de Etiqueta</h3>
                                <div id="preview-container" className="border-2 border-dashed border-gray-400 w-full" style={{height: '65vh'}}>
                                    {previewPdfUrl ? (
                                        <iframe id="preview-iframe" src={previewPdfUrl} title="Vista Previa de Etiqueta"></iframe>
                                    ) : (
                                        <div className="text-center text-gray-500 flex items-center justify-center h-full">
                                            <p>Complete el formulario y genere la vista previa</p>
                                        </div>
                                    )}
                                </div>
                                {previewPdfUrl && (
                                    <button onClick={handleGenerateAndPrintPDF} disabled={isSaving} className="w-full mt-4 bg-green-600 text-white font-semibold py-3 px-4 rounded-md shadow-md hover:bg-green-700 text-xl flex items-center justify-center disabled:opacity-60 disabled:cursor-wait">
                                        {isSaving && <span className="spinner"></span>}
                                        {isSaving ? 'Guardando...' : '🖨️ Imprimir y Guardar'}
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            </Fragment>
        );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<AppWrapper />);

</script>
</body>
</html>
